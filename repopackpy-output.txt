================================================================
RepopackPy Output File
================================================================

This file was generated by RepopackPy on: 2024-11-14T14:35:00.271339

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and RepopackPy's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

For more information about RepopackPy, visit: https://github.com/abinthomasonline/repopack-py

================================================================
Repository Structure
================================================================
.github\CODEOWNERS
.github\workflows\ci.yml
LICENSE
README.md
assets\limonata_banner.png
docs\Makefile
docs\api_reference.md
docs\conf.py
docs\firmware_guide.md
docs\index.rst
docs\make.bat
docs\source\limonata.actuators.rst
docs\source\limonata.control_algorithms.advanced.rst
docs\source\limonata.control_algorithms.machine_learning.rst
docs\source\limonata.control_algorithms.rst
docs\source\limonata.control_algorithms.state_estimation.rst
docs\source\limonata.control_algorithms.supervisory.rst
docs\source\limonata.rst
docs\source\limonata.safety.rst
docs\source\limonata.sensors.rst
docs\source\modules.rst
docs\user_guide.md
firmware\__init__.py
firmware\communication.cpp
firmware\firmware.ino
firmware\utilities.cpp
limonata\__init__.py
limonata\actuators\__init__.py
limonata\actuators\agitators.py
limonata\actuators\base.py
limonata\actuators\heaters.py
limonata\actuators\pumps.py
limonata\actuators\valves.py
limonata\config_manager.py
limonata\control_algorithms\__init__.py
limonata\control_algorithms\advanced\__init__.py
limonata\control_algorithms\advanced\adaptive.py
limonata\control_algorithms\advanced\lqr.py
limonata\control_algorithms\advanced\mpc.py
limonata\control_algorithms\advanced\robust.py
limonata\control_algorithms\advanced\smc.py
limonata\control_algorithms\machine_learning\__init__.py
limonata\control_algorithms\machine_learning\fuzzy_logic.py
limonata\control_algorithms\machine_learning\nn.py
limonata\control_algorithms\machine_learning\rl.py
limonata\control_algorithms\state_estimation\__init__.py
limonata\control_algorithms\state_estimation\extended_kalman_filter.py
limonata\control_algorithms\state_estimation\kalman_filter.py
limonata\control_algorithms\state_estimation\particle_filter.py
limonata\control_algorithms\supervisory\__init__.py
limonata\control_algorithms\supervisory\rule_based.py
limonata\control_algorithms\supervisory\scada.py
limonata\control_algorithms\supervisory\scheduling.py
limonata\data_logging.py
limonata\reactor.py
limonata\safety\__init__.py
limonata\safety\fault_detection.py
limonata\safety\hazard_identification.py
limonata\safety\risk_assessment.py
limonata\safety\transient_analysis.py
limonata\sensor_data_processing.py
limonata\sensors\__init__.py
limonata\sensors\base.py
limonata\sensors\density_sensor.py
limonata\sensors\flow_sensor.py
limonata\sensors\level_sensor.py
limonata\sensors\load_cell.py
limonata\sensors\ph_sensor.py
limonata\sensors\pressure_sensor.py
limonata\serial_comm.py
limonata\simulation\manager.py
limonata\timer.py
limonata\utils.py
limonata\version.py
main.py
pyproject.toml
tests\test_reactor.py

================================================================
Repository Files
================================================================

================
File: LICENSE
================
MIT License

Copyright (c) 2022 Ross Lee

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: main.py
================
import numpy as np
import pandas as pd
import limonata
import time
import pyqtgraph as pg
from pyqtgraph.Qt import QtWidgets, QtCore  # Updated to use QtWidgets

# generate step test data on Arduino
filename = 'limonata_dyn_data1.csv'

# heater steps
Qd = np.zeros(601)
Qd[10:200] = 80
Qd[200:400] = 20
Qd[400:] = 50

# Connect to Arduino
a = limonata.ReactorModel()
fid = open(filename, 'w')
fid.write('Time,H1,T1\n')
fid.close()

# Create PyQtGraph application
app = QtWidgets.QApplication([])  # Updated to use QtWidgets.QApplication
win = pg.GraphicsLayoutWidget(show=True)
win.setWindowTitle('Real-time Plotting')

# Create two plots: one for heater, one for temperature
heater_plot = win.addPlot(title="Heater Output (%)")
heater_curve = heater_plot.plot(pen='b')

win.nextRow()  # Move to the next row in the grid layout

temp_plot = win.addPlot(title="Temperature (degC)")
temp_curve = temp_plot.plot(pen='r')

# Set axes labels
heater_plot.setLabel('left', 'Heater (%)')
heater_plot.setLabel('bottom', 'Time (s)')
temp_plot.setLabel('left', 'Temperature (degC)')
temp_plot.setLabel('bottom', 'Time (s)')

# Initialize data containers for real-time updating
time_vals = []
heater_vals = []
temp_vals = []

# PyQtGraph timer for real-time updates
timer = QtCore.QTimer()

def update_plot():
    i = len(time_vals)
    if i >= 601:
        timer.stop()
        a.close()  # Close the connection when finished
        return
    
    # Set heater value and get temperature
    a.Q1(Qd[i])
    time_vals.append(i)
    heater_vals.append(Qd[i])
    temp_vals.append(a.T1)

    # Update the curves with new data
    heater_curve.setData(time_vals, heater_vals)
    temp_curve.setData(time_vals, temp_vals)

    # Write data to CSV
    with open(filename, 'a') as fid:
        fid.write(f'{i},{Qd[i]},{a.T1}\n')

    # Print to console
    print(f'Time: {i}, H1: {Qd[i]}, T1: {a.T1}')

# Set timer to update the plot every second
timer.timeout.connect(update_plot)
timer.start(1000)  # 1000 ms = 1 second

# Start the PyQtGraph application
app.exec_()  # Updated to use app.exec_()

================
File: pyproject.toml
================
[tool.poetry]
name = "limonata"
version = "0.1.0"
description = "A modular reactor and control system for prototyping chemical processes."
authors = ["Ross Lee <ross_j_lee@outlook.com>"]
license = "MIT"
readme = "README.md"

[tool.poetry.dependencies]
python = "^3.11"
numpy = "^2.1.2"
scipy = "^1.14.1"
matplotlib = "^3.9.2"
pyserial = "^3.5"
requests = "^2.32.3"
pandas = "^2.2.3"


[tool.poetry.group.dev.dependencies]
pytest = "^8.3.3"
ruff = "^0.7.0"
mypy = "^1.12.0"
pytest-cov = "^5.0.0"
sphinx = "^8.1.3"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"

================
File: README.md
================
![Limonata Logo Banner](assets/limonata_banner.png)

# âš™ï¸ Limonata: Your Process Prototyping Platform

Limonata is an open-source, modular prototyping device designed for students, educators, and makers across engineering disciplines. Inspired by Arduino's versatility and simplicity, Limonata helps you create, control, and iterate on complex process engineering projects with ease.

## ðŸŒ What is Limonata?
Limonata is a flexible platform for anyone looking to prototype process control systems. Whether youâ€™re a chemical engineer, a food technologist, a process designer, or a DIYer, Limonata provides a plug-and-play solution to bring your ideas to life. From precise mixing to flow and temperature control, Limonata is built to handle a wide range of applications.

### Key Features
- **Versatile Design:** Modular setup with T-slot aluminum framing and easy-to-connect components for endless configurations.
- **Python and Arduino Integration:** Control your process using Python for advanced scripting or leverage Arduinoâ€™s real-time capabilities.
- **For Everyone:** Ideal for prototyping in industries like food and beverage, pharmaceuticals, cosmetics, and general manufacturing.
- **Community-Driven:** Join a growing ecosystem of makers and engineers sharing projects and collaborating on new ideas.

## ðŸ› ï¸ Get Started
1. **Clone the Repository:**
   ```bash
   git clone https://github.com/yourusername/limonata.git
   cd limonata
   ```
2. **Install Dependencies with Poetry:**
   ```bash
   poetry install
   ```
3. **Run an Example Process:**
   ```bash
   python main.py
   ```

## ðŸ’¡ Use Cases
- **Food & Beverage:** Mix and control temperatures for brewing, fermentation, or flavor testing.
- **Pharma & Biotech:** Prototype bioreactors and chemical synthesis processes.
- **General Process Engineering:** Experiment with flow control, heating, and automated sampling.

## ðŸ“œ License
Limonata is released under the MIT License. See the [LICENSE](LICENSE) file for more details.

================
File: .github\CODEOWNERS
================
@leeros00

================
File: .github\workflows\ci.yml
================
name: CI Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  lint-test:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        python-version: [3.11]

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}

    - name: Install Poetry
      run: |
        curl -sSL https://install.python-poetry.org | python3 -
        echo "${HOME}/.local/bin" >> $GITHUB_PATH

    - name: Install dependencies
      run: |
        poetry install

    - name: Set PYTHONPATH
      run: echo "PYTHONPATH=$(pwd)" >> $GITHUB_ENV

    - name: Run linting
      run: poetry run ruff check --fix 

    - name: Run type-checking
      run: poetry run mypy limonata

    - name: Formatting
      run: poetry run ruff format

    - name: Check dependency updates
      run: poetry update

    - name: Build Sphinx documentation
      run: |
        cd docs
        poetry run sphinx-apidoc -o source/ ../limonata
        poetry run make html

================
File: docs\conf.py
================
# Configuration file for the Sphinx documentation builder.
#
# For the full list of built-in configuration values, see the documentation:
# https://www.sphinx-doc.org/en/master/usage/configuration.html

# -- Project information -----------------------------------------------------
# https://www.sphinx-doc.org/en/master/usage/configuration.html#project-information

import os
import sys

sys.path.insert(0, os.path.abspath("../limonata"))

extensions = [
    "sphinx.ext.autodoc",
    "sphinx.ext.napoleon",  # Optional, for Google/NumPy-style docstrings
]


project = "limonata"
copyright = "2024, Ross Lee"
author = "Ross Lee"
release = "0.1.0"

# -- General configuration ---------------------------------------------------
# https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration

extensions = []

templates_path = ["_templates"]
exclude_patterns = ["_build", "Thumbs.db", ".DS_Store"]


# -- Options for HTML output -------------------------------------------------
# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output

html_theme = "alabaster"
html_static_path = ["_static"]

================
File: docs\index.rst
================
.. limonata documentation master file, created by
   sphinx-quickstart on Thu Oct 17 18:36:17 2024.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

limonata documentation
======================

Add your content using ``reStructuredText`` syntax. See the
`reStructuredText <https://www.sphinx-doc.org/en/master/usage/restructuredtext/index.html>`_
documentation for details.


.. toctree::
   :maxdepth: 2
   :caption: Contents:

================
File: docs\make.bat
================
@ECHO OFF

pushd %~dp0

REM Command file for Sphinx documentation

if "%SPHINXBUILD%" == "" (
	set SPHINXBUILD=sphinx-build
)
set SOURCEDIR=.
set BUILDDIR=_build

%SPHINXBUILD% >NUL 2>NUL
if errorlevel 9009 (
	echo.
	echo.The 'sphinx-build' command was not found. Make sure you have Sphinx
	echo.installed, then set the SPHINXBUILD environment variable to point
	echo.to the full path of the 'sphinx-build' executable. Alternatively you
	echo.may add the Sphinx directory to PATH.
	echo.
	echo.If you don't have Sphinx installed, grab it from
	echo.https://www.sphinx-doc.org/
	exit /b 1
)

if "%1" == "" goto help

%SPHINXBUILD% -M %1 %SOURCEDIR% %BUILDDIR% %SPHINXOPTS% %O%
goto end

:help
%SPHINXBUILD% -M help %SOURCEDIR% %BUILDDIR% %SPHINXOPTS% %O%

:end
popd

================
File: docs\Makefile
================
# Minimal makefile for Sphinx documentation
#

# You can set these variables from the command line, and also
# from the environment for the first two.
SPHINXOPTS    ?=
SPHINXBUILD   ?= sphinx-build
SOURCEDIR     = .
BUILDDIR      = _build

# Put it first so that "make" without argument is like "make help".
help:
	@$(SPHINXBUILD) -M help "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)

.PHONY: help Makefile

# Catch-all target: route all unknown targets to Sphinx using the new
# "make mode" option.  $(O) is meant as a shortcut for $(SPHINXOPTS).
%: Makefile
	@$(SPHINXBUILD) -M $@ "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)

================
File: docs\source\limonata.actuators.rst
================
limonata.actuators package
==========================

Submodules
----------

limonata.actuators.agitator module
----------------------------------

.. automodule:: limonata.actuators.agitator
   :members:
   :undoc-members:
   :show-inheritance:

limonata.actuators.bldc\_pump module
------------------------------------

.. automodule:: limonata.actuators.bldc_pump
   :members:
   :undoc-members:
   :show-inheritance:

limonata.actuators.heat\_element module
---------------------------------------

.. automodule:: limonata.actuators.heat_element
   :members:
   :undoc-members:
   :show-inheritance:

limonata.actuators.peristaltic\_pump module
-------------------------------------------

.. automodule:: limonata.actuators.peristaltic_pump
   :members:
   :undoc-members:
   :show-inheritance:

Module contents
---------------

.. automodule:: limonata.actuators
   :members:
   :undoc-members:
   :show-inheritance:

================
File: docs\source\limonata.control_algorithms.advanced.rst
================
limonata.control\_algorithms.advanced package
=============================================

Submodules
----------

limonata.control\_algorithms.advanced.adaptive module
-----------------------------------------------------

.. automodule:: limonata.control_algorithms.advanced.adaptive
   :members:
   :undoc-members:
   :show-inheritance:

limonata.control\_algorithms.advanced.lqr module
------------------------------------------------

.. automodule:: limonata.control_algorithms.advanced.lqr
   :members:
   :undoc-members:
   :show-inheritance:

limonata.control\_algorithms.advanced.mpc module
------------------------------------------------

.. automodule:: limonata.control_algorithms.advanced.mpc
   :members:
   :undoc-members:
   :show-inheritance:

limonata.control\_algorithms.advanced.robust module
---------------------------------------------------

.. automodule:: limonata.control_algorithms.advanced.robust
   :members:
   :undoc-members:
   :show-inheritance:

limonata.control\_algorithms.advanced.smc module
------------------------------------------------

.. automodule:: limonata.control_algorithms.advanced.smc
   :members:
   :undoc-members:
   :show-inheritance:

Module contents
---------------

.. automodule:: limonata.control_algorithms.advanced
   :members:
   :undoc-members:
   :show-inheritance:

================
File: docs\source\limonata.control_algorithms.machine_learning.rst
================
limonata.control\_algorithms.machine\_learning package
======================================================

Submodules
----------

limonata.control\_algorithms.machine\_learning.fuzzy\_logic module
------------------------------------------------------------------

.. automodule:: limonata.control_algorithms.machine_learning.fuzzy_logic
   :members:
   :undoc-members:
   :show-inheritance:

limonata.control\_algorithms.machine\_learning.nn module
--------------------------------------------------------

.. automodule:: limonata.control_algorithms.machine_learning.nn
   :members:
   :undoc-members:
   :show-inheritance:

limonata.control\_algorithms.machine\_learning.rl module
--------------------------------------------------------

.. automodule:: limonata.control_algorithms.machine_learning.rl
   :members:
   :undoc-members:
   :show-inheritance:

Module contents
---------------

.. automodule:: limonata.control_algorithms.machine_learning
   :members:
   :undoc-members:
   :show-inheritance:

================
File: docs\source\limonata.control_algorithms.rst
================
limonata.control\_algorithms package
====================================

Subpackages
-----------

.. toctree::
   :maxdepth: 4

   limonata.control_algorithms.advanced
   limonata.control_algorithms.machine_learning
   limonata.control_algorithms.state_estimation
   limonata.control_algorithms.supervisory

Module contents
---------------

.. automodule:: limonata.control_algorithms
   :members:
   :undoc-members:
   :show-inheritance:

================
File: docs\source\limonata.control_algorithms.state_estimation.rst
================
limonata.control\_algorithms.state\_estimation package
======================================================

Submodules
----------

limonata.control\_algorithms.state\_estimation.extended\_kalman\_filter module
------------------------------------------------------------------------------

.. automodule:: limonata.control_algorithms.state_estimation.extended_kalman_filter
   :members:
   :undoc-members:
   :show-inheritance:

limonata.control\_algorithms.state\_estimation.kalman\_filter module
--------------------------------------------------------------------

.. automodule:: limonata.control_algorithms.state_estimation.kalman_filter
   :members:
   :undoc-members:
   :show-inheritance:

limonata.control\_algorithms.state\_estimation.particle\_filter module
----------------------------------------------------------------------

.. automodule:: limonata.control_algorithms.state_estimation.particle_filter
   :members:
   :undoc-members:
   :show-inheritance:

Module contents
---------------

.. automodule:: limonata.control_algorithms.state_estimation
   :members:
   :undoc-members:
   :show-inheritance:

================
File: docs\source\limonata.control_algorithms.supervisory.rst
================
limonata.control\_algorithms.supervisory package
================================================

Submodules
----------

limonata.control\_algorithms.supervisory.rule\_based module
-----------------------------------------------------------

.. automodule:: limonata.control_algorithms.supervisory.rule_based
   :members:
   :undoc-members:
   :show-inheritance:

limonata.control\_algorithms.supervisory.scada module
-----------------------------------------------------

.. automodule:: limonata.control_algorithms.supervisory.scada
   :members:
   :undoc-members:
   :show-inheritance:

limonata.control\_algorithms.supervisory.scheduling module
----------------------------------------------------------

.. automodule:: limonata.control_algorithms.supervisory.scheduling
   :members:
   :undoc-members:
   :show-inheritance:

Module contents
---------------

.. automodule:: limonata.control_algorithms.supervisory
   :members:
   :undoc-members:
   :show-inheritance:

================
File: docs\source\limonata.rst
================
limonata package
================

Subpackages
-----------

.. toctree::
   :maxdepth: 4

   limonata.actuators
   limonata.control_algorithms
   limonata.safety
   limonata.sensors

Submodules
----------

limonata.config\_manager module
-------------------------------

.. automodule:: limonata.config_manager
   :members:
   :undoc-members:
   :show-inheritance:

limonata.data\_logging module
-----------------------------

.. automodule:: limonata.data_logging
   :members:
   :undoc-members:
   :show-inheritance:

limonata.reactor module
-----------------------

.. automodule:: limonata.reactor
   :members:
   :undoc-members:
   :show-inheritance:

limonata.sensor\_data\_processing module
----------------------------------------

.. automodule:: limonata.sensor_data_processing
   :members:
   :undoc-members:
   :show-inheritance:

limonata.serial\_comm module
----------------------------

.. automodule:: limonata.serial_comm
   :members:
   :undoc-members:
   :show-inheritance:

Module contents
---------------

.. automodule:: limonata
   :members:
   :undoc-members:
   :show-inheritance:

================
File: docs\source\limonata.safety.rst
================
limonata.safety package
=======================

Submodules
----------

limonata.safety.fault\_detection module
---------------------------------------

.. automodule:: limonata.safety.fault_detection
   :members:
   :undoc-members:
   :show-inheritance:

limonata.safety.hazard\_identification module
---------------------------------------------

.. automodule:: limonata.safety.hazard_identification
   :members:
   :undoc-members:
   :show-inheritance:

limonata.safety.risk\_assessment module
---------------------------------------

.. automodule:: limonata.safety.risk_assessment
   :members:
   :undoc-members:
   :show-inheritance:

limonata.safety.transient\_analysis module
------------------------------------------

.. automodule:: limonata.safety.transient_analysis
   :members:
   :undoc-members:
   :show-inheritance:

Module contents
---------------

.. automodule:: limonata.safety
   :members:
   :undoc-members:
   :show-inheritance:

================
File: docs\source\limonata.sensors.rst
================
limonata.sensors package
========================

Submodules
----------

limonata.sensors.density\_sensor module
---------------------------------------

.. automodule:: limonata.sensors.density_sensor
   :members:
   :undoc-members:
   :show-inheritance:

limonata.sensors.flow\_sensor module
------------------------------------

.. automodule:: limonata.sensors.flow_sensor
   :members:
   :undoc-members:
   :show-inheritance:

limonata.sensors.level\_sensor module
-------------------------------------

.. automodule:: limonata.sensors.level_sensor
   :members:
   :undoc-members:
   :show-inheritance:

limonata.sensors.load\_cell module
----------------------------------

.. automodule:: limonata.sensors.load_cell
   :members:
   :undoc-members:
   :show-inheritance:

limonata.sensors.ph\_sensor module
----------------------------------

.. automodule:: limonata.sensors.ph_sensor
   :members:
   :undoc-members:
   :show-inheritance:

limonata.sensors.pressure\_sensor module
----------------------------------------

.. automodule:: limonata.sensors.pressure_sensor
   :members:
   :undoc-members:
   :show-inheritance:

Module contents
---------------

.. automodule:: limonata.sensors
   :members:
   :undoc-members:
   :show-inheritance:

================
File: docs\source\modules.rst
================
limonata
========

.. toctree::
   :maxdepth: 4

   limonata

================
File: firmware\firmware.ino
================
/*
Limonata Firmware
Ross Lee
September 2023
*/

#include "Arduino.h"

// determine board type
#if defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__)
  String boardType = "Arduino Uno";
#elif defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega16U4__)
  String boardType = "Arduino Leonardo/Micro";
#elif defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
  String boardType = "Arduino Mega";
#elif defined(ARDUINO_ARCH_STM32) || defined(ARDUINO_GIGA)
String boardType = "Arduino Giga";
#else 
  String boardType = "Unknown board";
#endif

// Enable debugging output
const bool DEBUG = false;

// constants
const String vers = "0.1.0";   // version of this firmware
const long baud = 115200;      // serial baud rate
const char sp = ' ';           // command separator
const char nl = '\n';          // command terminator


const int pinT1   = 0;         // T1
const int pinT2   = 2;         // T2
const int pinQ1   = 3;         // Q1
const int pinQ2   = 5;         // Q2
const int pinLED1 = 9;         // LED1

// temperature alarm limits
const int limT1   = 50;       // T1 high alarm (Â°C)
const int limT2   = 50;       // T2 high alarm (Â°C)

// LED1 levels
const int hiLED   =  60;       // hi LED
const int loLED   = hiLED/16;  // lo LED

// global variables
char Buffer[64];               // buffer for parsing serial input
int buffer_index = 0;          // index for Buffer
String cmd;                    // command
float val;                     // command value
int ledStatus;                 // 1: loLED
                               // 2: hiLED
                               // 3: loLED blink
                               // 4: hiLED blink
long ledTimeout = 0;           // when to return LED to normal operation
float LED = 100;               // LED override brightness
float P1 = 200;                // heater 1 power limit in units of pwm. Range 0 to 255
float P2 = 100;                // heater 2 power limit in units in pwm, range 0 to 255
float Q1 = 0;                  // last value written to heater 1 in units of percent
float Q2 = 0;                  // last value written to heater 2 in units of percent
int alarmStatus;               // hi temperature alarm status
boolean newData = false;       // boolean flag indicating new command
int n =  10;                   // number of samples for each temperature measurement


void readCommand() {
  while (Serial && (Serial.available() > 0) && (newData == false)) {
    int byte = Serial.read();
    if ((byte != '\r') && (byte != nl) && (buffer_index < 64)) {
      Buffer[buffer_index] = byte;
      buffer_index++;
    }
    else {
      newData = true;
    }
  }   
}

// for debugging with the serial monitor in Arduino IDE
void echoCommand() {
  if (newData) {
    Serial.write("Received Command: ");
    Serial.write(Buffer, buffer_index);
    Serial.write(nl);
    Serial.flush();
  }
}

// return average  of n reads of thermister temperature in Â°C
inline float readTemperature(int pin) {
  float degC = 0.0;
  for (int i = 0; i < n; i++) {
    degC += analogRead(pin) * 0.322265625 - 50.0;    // use for 3.3v AREF
    //degC += analogRead(pin) * 0.170898438 - 50.0;  // use for 1.75v AREF
  }
  return degC / float(n);
}

void parseCommand(void) {
  if (newData) {
    String read_ = String(Buffer);

    // separate command from associated data
    int idx = read_.indexOf(sp);
    cmd = read_.substring(0, idx);
    cmd.trim();
    cmd.toUpperCase();

    // extract data. toFloat() returns 0 on error
    String data = read_.substring(idx + 1);
    data.trim();
    val = data.toFloat();

    // reset parameter for next command
    memset(Buffer, 0, sizeof(Buffer));
    buffer_index = 0;
    newData = false;
  }
}

void sendResponse(String msg) {
  Serial.println(msg);
}

void sendFloatResponse(float val) {
  Serial.println(String(val, 3));
}

void sendBinaryResponse(float val) {
  byte *b = (byte*)&val;
  Serial.write(b, 4);  
}

void dispatchCommand(void) {
  if (cmd == "A") {
    setHeater1(0);
    setHeater2(0);
    sendResponse("Start");
  }
  else if (cmd == "LED") {
    ledTimeout = millis() + 10000;
    LED = max(0, min(100, val));
    sendResponse(String(LED));
  }
  else if (cmd == "P1") {
    P1 = max(0, min(255, val));
    sendResponse(String(P1));
  }
  else if (cmd == "P2") {
    P2 = max(0, min(255, val));
    sendResponse(String(P2));
  }
  else if (cmd == "Q1") {
    setHeater1(val);
    sendFloatResponse(Q1);
  }
  else if (cmd == "Q1B") {
    setHeater1(val);
    sendBinaryResponse(Q1);
  }
  else if (cmd == "Q2") {
    setHeater2(val);
    sendFloatResponse(Q2);
  }
  else if (cmd == "Q2B") {
    setHeater1(val);
    sendBinaryResponse(Q2);
  }
  else if (cmd == "R1") {
    sendFloatResponse(Q1);
  }
  else if (cmd == "R2") {
    sendFloatResponse(Q2);
  }
  else if (cmd == "SCAN") {
    sendFloatResponse(readTemperature(pinT1));
    sendFloatResponse(readTemperature(pinT2));
    sendFloatResponse(Q1);
    sendFloatResponse(Q2);
  }
  else if (cmd == "T1") {
    sendFloatResponse(readTemperature(pinT1));
  }
  else if (cmd == "T1B") {
    sendBinaryResponse(readTemperature(pinT1));
  }
  else if (cmd == "T2") {
    sendFloatResponse(readTemperature(pinT2));
  }
  else if (cmd == "T2B") {
    sendBinaryResponse(readTemperature(pinT2));
  }
  else if (cmd == "VER") {
    sendResponse("TCLab Firmware " + vers + " " + boardType);
  }
  else if (cmd == "X") {
    setHeater1(0);
    setHeater2(0);
    sendResponse("Stop");
  }
  else if (cmd.length() > 0) {
    setHeater1(0);
    setHeater2(0);
    sendResponse(cmd);
  }
  Serial.flush();
  cmd = "";
}

void checkAlarm(void) {
  if ((readTemperature(pinT1) > limT1) or (readTemperature(pinT2) > limT2)) {
    alarmStatus = 1;
  }
  else {
    alarmStatus = 0;
  }
}

void updateStatus(void) {
  // determine led status
  ledStatus = 1;
  if ((Q1 > 0) or (Q2 > 0)) {
    ledStatus = 2;
  }
  if (alarmStatus > 0) {
    ledStatus += 2;
  }
  // update led depending on ledStatus
  if (millis() < ledTimeout) {        // override led operation
    analogWrite(pinLED1, LED);
  }
  else {
    switch (ledStatus) {
      case 1:  // normal operation, heaters off
        analogWrite(pinLED1, loLED);
        break;
      case 2:  // normal operation, heater on
        analogWrite(pinLED1, hiLED);
        break;
      case 3:  // high temperature alarm, heater off
        if ((millis() % 2000) > 1000) {
          analogWrite(pinLED1, loLED);
        } else {
          analogWrite(pinLED1, loLED/4);
        }
        break;
      case 4:  // high temperature alarm, heater on
        if ((millis() % 2000) > 1000) {
          analogWrite(pinLED1, hiLED);
        } else {
          analogWrite(pinLED1, loLED);
        }
        break;
    }   
  }
}

// set Heater 1
void setHeater1(float qval) {
  Q1 = max(0., min(qval, 100.));
  analogWrite(pinQ1, (Q1*P1)/100);
}

// set Heater 2
void setHeater2(float qval) {
  Q2 = max(0., min(qval, 100.));
  analogWrite(pinQ2, (Q2*P2)/100);
}

// arduino startup
void setup() {
  //analogReference(EXTERNAL);
  while (!Serial) {
    ; // wait for serial port to connect.
  }
  Serial.begin(baud);
  Serial.flush();
  setHeater1(0);
  setHeater2(0);
  ledTimeout = millis() + 1000;
}

// arduino main event loop
void loop() {
  readCommand();
  if (DEBUG) echoCommand();
  parseCommand();
  dispatchCommand();
  checkAlarm();
  updateStatus();
}

================
File: limonata\data_logging.py
================
class DataLogger:
    def __init__(self):
        self.log = []

    
    def log(self, sensor_data: float) -> None:
        self.log.append(sensor_data)

================
File: limonata\reactor.py
================
from __future__ import print_function
import time
import random
import serial  # type: ignore
from serial.tools import list_ports  # type: ignore
from limonata.timer import timer
from limonata.version import __version__

from typing import Callable, Any

sep: str = " "  # command/value separator in Reactor firmware

arduinos: list[tuple[str, str]] = [
    ("USB VID:PID=16D0:0613", "Arduino Uno"),
    ("USB VID:PID=1A86:7523", "NHduino"),
    ("USB VID:PID=2341:8036", "Arduino Leonardo"),
    ("USB VID:PID=2A03", "Arduino.org device"),
    ("USB VID:PID", "unknown device"),
]

_connected: bool = False


def clip(val: float, lower: float = 0, upper: float = 100) -> float:
    """Limit value to be between lower and upper limits"""
    return max(lower, min(val, upper))


def command(name: str, argument: float, lower: float = 0, upper: float = 100) -> str:
    """Construct command to the firmware."""
    return name + sep + str(clip(argument, lower, upper))


def find_arduino(port: str = "") -> tuple[str | None, str | None]:
    """Locates Arduino and returns port and device."""
    comports: list[tuple[str, str, str]] = [
        tuple for tuple in list_ports.comports() if port in tuple[0]
    ]
    for port, desc, hwid in comports:
        for identifier, arduino in arduinos:
            if hwid.startswith(identifier):
                return port, arduino
    print("--- Serial Ports ---")
    for port, desc, hwid in list_ports.comports():
        print(port, desc, hwid)
    return None, None


class AlreadyConnectedError(Exception):
    pass


class Reactor:
    def __init__(self, port: str = "", debug: bool = False):
        global _connected
        self.debug: bool = debug
        print("Reactor version", __version__)
        self.port, self.arduino = find_arduino(port)
        if self.port is None:
            raise RuntimeError("No Arduino device found.")

        try:
            self.connect(baud=115200)
        except AlreadyConnectedError:
            raise
        except Exception as e:
            print(f"Error occurred: {e}")
            try:
                _connected = False
                self.sp.close()
                self.connect(baud=9600)
                print("Could not connect at high speed, but succeeded at low speed.")
            except Exception as e:
                print(f"Failed to connect: {e}")
                raise RuntimeError("Failed to connect.")

        self.sp.readline().decode("UTF-8")
        self.version: str = self.send_and_receive("VER")
        if self.sp.isOpen():
            print(
                self.arduino, "connected on port", self.port, "at", self.baud, "baud."
            )
            print(self.version + ".")
        timer.set_rate(1)
        timer.start()
        self._P1: float = 200.0
        self._P2: float = 100.0
        self.Q2(0)
        self.sources: list[tuple[str, Callable | None]] = [
            ("T1", self.scan),
            ("T2", None),
            ("Q1", None),
            ("Q2", None),
        ]

    def __enter__(self) -> "Reactor":
        return self

    def __exit__(
        self, exc_type: type | None, exc_value: Exception | None, traceback
    ) -> None:
        self.close()

    def connect(self, baud: int) -> None:
        """Establish a connection to the Arduino

        baud: baud rate"""
        global _connected

        if _connected:
            raise AlreadyConnectedError("You already have an open connection")

        _connected = True
        self.sp = serial.Serial(port=self.port, baudrate=baud, timeout=2)
        time.sleep(2)
        self.Q1(0)  # fails if not connected
        self.baud: int = baud

    def close(self) -> None:
        """Shut down Reactor device and close serial connection."""
        global _connected

        self.Q1(0)
        self.Q2(0)
        self.send_and_receive("X")
        self.sp.close()
        _connected = False
        print("Reactor disconnected successfully.")

    def send(self, msg: str) -> None:
        """Send a string message to the Reactor firmware."""
        self.sp.write((msg + "\r\n").encode())
        if self.debug:
            print('Sent: "' + msg + '"')
        self.sp.flush()

    def receive(self) -> str:
        """Return a string message received from the Reactor firmware."""
        msg: str = self.sp.readline().decode("UTF-8").replace("\r\n", "")
        if self.debug:
            print('Return: "' + msg + '"')
        return msg

    def send_and_receive(self, msg: str, convert: type = str) -> Any:
        """Send a string message and return the response"""
        self.send(msg)
        return convert(self.receive())

    def LED(self, val: float = 100) -> float:
        """Flash Reactor LED at a specified brightness for 10 seconds."""
        return self.send_and_receive(command("LED", val), float)

    @property
    def T1(self) -> float:
        """Return a float denoting Reactor temperature T1 in degrees C."""
        return self.send_and_receive("T1", float)

    @property
    def T2(self) -> float:
        """Return a float denoting Reactor temperature T2 in degrees C."""
        return self.send_and_receive("T2", float)

    @property
    def P1(self) -> float:
        """Return a float denoting maximum power of heater 1 in pwm."""
        return self._P1

    @P1.setter
    def P1(self, val: float) -> None:
        """Set maximum power of heater 1 in pwm, range 0 to 255."""
        self._P1 = self.send_and_receive(command("P1", val, 0, 255), float)

    @property
    def P2(self) -> float:
        """Return a float denoting maximum power of heater 2 in pwm."""
        return self._P2

    @P2.setter
    def P2(self, val: float) -> None:
        """Set maximum power of heater 2 in pwm, range 0 to 255."""
        self._P2 = self.send_and_receive(command("P2", val, 0, 255), float)

    def Q1(self, val: float | None = None) -> float:
        """Get or set Reactor heater power Q1

        val: Value of heater power, range is limited to 0-100

        return clipped value."""
        if val is None:
            msg = "R1"
        else:
            msg = "Q1" + sep + str(clip(val))
        return self.send_and_receive(msg, float)

    def Q2(self, val: float | None = None) -> float:
        """Get or set Reactor heater power Q2

        val: Value of heater power, range is limited to 0-100

        return clipped value."""
        if val is None:
            msg = "R2"
        else:
            msg = "Q2" + sep + str(clip(val))
        return self.send_and_receive(msg, float)

    def scan(self) -> tuple[float, float, float, float]:
        T1: float = self.T1
        T2: float = self.T2
        Q1: float = self.Q1()
        Q2: float = self.Q2()
        return T1, T2, Q1, Q2

    U1 = property(
        fget=lambda self: self.Q1(),
        fset=lambda self, val: self.Q1(val),
        doc="Heater 1 value",
    )

    U2 = property(
        fget=lambda self: self.Q2(),
        fset=lambda self, val: self.Q2(val),
        doc="Heater 2 value",
    )


class ReactorModel:
    def __init__(self, port: str = "", debug: bool = False, synced: bool = True):
        self.debug: bool = debug
        self.synced: bool = synced
        print("Reactor version", __version__)
        timer.start()
        print("Simulated Reactor")
        self.Ta: float = 21  # ambient temperature
        self.tstart: float = timer.time()  # start time
        self.tlast: float = self.tstart  # last update time
        self._P1: float = 200.0  # max power heater 1
        self._P2: float = 100.0  # max power heater 2
        self._Q1: float = 0  # initial heater 1
        self._Q2: float = 0  # initial heater 2
        self._T1: float = self.Ta  # temperature thermistor 1
        self._T2: float = self.Ta  # temperature thermistor 2
        self._H1: float = self.Ta  # temperature heater 1
        self._H2: float = self.Ta  # temperature heater 2
        self.maxstep: float = 0.2  # maximum time step for integration
        self.sources: list[tuple[str, Callable | None]] = [
            ("T1", self.scan),
            ("T2", None),
            ("Q1", None),
            ("Q2", None),
        ]

    def __enter__(self) -> "ReactorModel":
        return self

    def __exit__(
        self, exc_type: type | None, exc_value: Exception | None, traceback
    ) -> None:
        self.close()

    def close(self) -> None:
        """Simulate shutting down Reactor device."""
        self.Q1(0)
        self.Q2(0)
        print("Reactor Model disconnected successfully.")

    def LED(self, val: float = 100) -> float:
        """Simulate flashing Reactor LED

        val : specified brightness (default 100)."""
        self.update()
        return clip(val)

    @property
    def T1(self) -> float:
        """Return a float denoting Reactor temperature T1 in degrees C."""
        self.update()
        return self.measurement(self._T1)

    @property
    def T2(self) -> float:
        """Return a float denoting Reactor temperature T2 in degrees C."""
        self.update()
        return self.measurement(self._T2)

    @property
    def P1(self) -> float:
        """Return a float denoting maximum power of heater 1 in pwm."""
        self.update()
        return self._P1

    @P1.setter
    def P1(self, val: float) -> None:
        """Set maximum power of heater 1 in pwm, range 0 to 255."""
        self.update()
        self._P1 = clip(val, 0, 255)

    @property
    def P2(self) -> float:
        """Return a float denoting maximum power of heater 2 in pwm."""
        self.update()
        return self._P2

    @P2.setter
    def P2(self, val: float) -> None:
        """Set maximum power of heater 2 in pwm, range 0 to 255."""
        self.update()
        self._P2 = clip(val, 0, 255)

    def Q1(self, val: float | None = None) -> float:
        """Get or set ReactorModel heater power Q1

        val: Value of heater power, range is limited to 0-100

        return clipped value."""
        self.update()
        if val is not None:
            self._Q1 = clip(val)
        return self._Q1

    def Q2(self, val: float | None = None) -> float:
        """Get or set ReactorModel heater power Q2

        val: Value of heater power, range is limited to 0-100

        return clipped value."""
        self.update()
        if val is not None:
            self._Q2 = clip(val)
        return self._Q2

    def scan(self) -> tuple[float, float, float, float]:
        self.update()
        return (
            self.measurement(self._T1),
            self.measurement(self._T2),
            self._Q1,
            self._Q2,
        )

    U1 = property(
        fget=lambda self: self.Q1(),
        fset=lambda self, val: self.Q1(val),
        doc="Heater 1 value",
    )

    U2 = property(
        fget=lambda self: self.Q2(),
        fset=lambda self, val: self.Q2(val),
        doc="Heater 2 value",
    )

    def quantize(self, T: float) -> float:
        """Quantize model temperatures to mimic Arduino A/D conversion."""
        return max(-50, min(132.2, T - T % 0.3223))

    def measurement(self, T: float) -> float:
        return self.quantize(T + random.normalvariate(0, 0.043))

    def update(self, t: float | None = None) -> None:
        if t is None:
            if self.synced:
                self.tnow: float = timer.time() - self.tstart
            else:
                return
        else:
            self.tnow = t

        teuler: float = self.tlast

        while teuler < self.tnow:
            dt: float = min(self.maxstep, self.tnow - teuler)
            DeltaTaH1: float = self.Ta - self._H1
            DeltaTaH2: float = self.Ta - self._H2
            DeltaT12: float = self._H1 - self._H2
            dH1: float = self._P1 * self._Q1 / 5720 + DeltaTaH1 / 20 - DeltaT12 / 100
            dH2: float = self._P2 * self._Q2 / 5720 + DeltaTaH2 / 20 + DeltaT12 / 100
            dT1: float = (self._H1 - self._T1) / 140
            dT2: float = (self._H2 - self._T2) / 140

            self._H1 += dt * dH1
            self._H2 += dt * dH2
            self._T1 += dt * dT1
            self._T2 += dt * dT2
            teuler += dt

        self.tlast = self.tnow


def diagnose(port: str = "") -> None:
    def countdown(t: int = 10) -> None:
        for i in reversed(range(t)):
            print("\r" + "Countdown: {0:d}  ".format(i), end="", flush=True)
            time.sleep(1)
        print()

    def heading(string: str) -> None:
        print()
        print(string)
        print("-" * len(string))

    heading("Checking connection")

    if port:
        print("Looking for Arduino on {} ...".format(port))
    else:
        print("Looking for Arduino on Any port...")
    comport, name = find_arduino(port=port)

    if comport is None:
        print("No known Arduino was found in the ports listed above.")
        return

    print(name, "found on port", comport)

    heading("Testing Reactor object in debug mode")

    with Reactor(port=port, debug=True) as reactor:
        print("Reading temperature")
        print(reactor.T1)

    heading("Testing Reactor functions")

    with Reactor(port=port) as reactor:
        print("Testing LED. Should turn on for 10 seconds.")
        reactor.LED(100)
        countdown()

        print()
        print("Reading temperatures")
        T1: float = reactor.T1
        T2: float = reactor.T2
        print("T1 = {} ì§¸C, T2 = {} ì§¸C".format(T1, T2))

        print()
        print("Writing fractional value to heaters...")
        try:
            Q1: float = reactor.Q1(0.5)
        except Exception as e:
            print(f"Error occurred while setting Q1: {e}")
            Q1 = -1.0
        print("We wrote Q1 = 0.5, and read back Q1 =", Q1)

        if Q1 != 0.5:
            print(
                "Your Reactor firmware version ({}) doesn't support"
                "fractional heater values.".format(reactor.version)
            )

        print()
        print(
            "We will now turn on the heaters, wait 30 seconds "
            "and see if the temperatures have gone up. "
        )
        reactor.Q1(100)
        reactor.Q2(100)
        countdown(30)

        print()

        def tempcheck(name: str, T_initial: float, T_final: float) -> None:
            print(
                "{} started at {} ì§¸C and went to {} ì§¸C".format(name, T_initial, T_final)
            )
            if T_final - T_initial < 0.8:
                print("The temperature went up less than expected.")
                print("Check the heater power supply.")

        T1_final: float = reactor.T1
        T2_final: float = reactor.T2

        tempcheck("T1", T1, T1_final)
        tempcheck("T2", T2, T2_final)

        print()
        heading("Throughput check")
        print("This part checks how fast your unit is")
        print("We will read T1 as fast as possible")

        start: float = time.time()
        n: int = 0
        while time.time() - start < 10:
            elapsed: float = time.time() - start + 0.0001  # avoid divide by zero
            T1 = reactor.T1
            n += 1
            print(
                "\rTime elapsed: {:3.2f} s."
                " Number of reads: {}."
                " Sampling rate: {:2.2f} Hz".format(elapsed, n, n / elapsed),
                end="",
            )

        print()

    print()
    print("Diagnostics complete")

================
File: limonata\timer.py
================
import time as time


class Timer:
    def __init__(self):
        self._realtime = time.time()
        self._timer = 0
        self._rate = 1
        self._running = True
        self.lastsleep = 0

    @property
    def running(self):
        """Returns variable indicating whether timer is running."""
        return self._running

    def time(self):
        """Return current timer."""
        if self.running:
            elapsed = time.time() - self._realtime
            return self._timer + self._rate * elapsed
        else:
            return self._timer

    def set_rate(self, rate=1):
        """Set the rate of timer relative to real time."""
        if rate <= 0:
            raise ValueError("timer rates must be positive.")
        self._timer = self.time()
        self._realtime = time.time()
        self._rate = rate

    def get_rate(self):
        """Return the rate of timer relative to real time."""
        return self._rate

    def sleep(self, delay):
        """Sleep in timer for a period delay."""
        self.lastsleep = delay
        if self._running:
            time.sleep(delay / self._rate)
        else:
            raise RuntimeWarning("sleep is not valid when timer is stopped.")

    def stop(self):
        """Stop timer."""
        self._timer = self.time()
        self._realtime = time.time()
        self._running = False

    def start(self):
        """Restart timer."""
        self._realtime = time.time()
        self._running = True

    def reset(self, val=0):
        """Reset timer to a specified value."""
        self._timer = val
        self._realtime = time.time()


timer = Timer()


# for backwards compatability
def setnow(tnow=0):
    timer.reset(tnow)


def clock(period, step=1, tol=float("inf"), adaptive=True):
    """Generator providing time values in sync with real time clock.

    Args:
        period (float): Time interval for clock operation in seconds.
        step (float): Time step.
        tol (float): Maximum permissible deviation from real time.
        adaptive (Boolean): If true, and if the rate != 1, then the timer
            rate is adjusted to maximize simulation speed.

    Yields:
        float: The next time step rounded to nearest 10th of a second.


    Note:
        * Passing `tol=float('inf')` will effectively disable sync error checking
        * When large values for `tol` are used, no guarantees are made that the
          last time returned will be equal to `period`.
    """
    start = timer.time()
    now = 0

    while round(now, 0) <= period:
        yield round(now, 2)
        if round(now) >= period:
            break
        elapsed = timer.time() - (start + now)
        rate = timer.get_rate()
        if (rate != 1) and adaptive:
            if elapsed > step:
                timer.set_rate(0.8 * rate * step / elapsed)
            elif (elapsed < 0.5 * step) & (rate < 50):
                timer.set_rate(1.25 * rate)
        else:
            if elapsed > step + tol:
                message = (
                    "timer clock lost synchronization with real time. "
                    "Step size was {} s, but {:.2f} s elapsed "
                    "({:.2f} too long). Consider increasing step."
                )
                raise RuntimeError(message.format(step, elapsed, elapsed - step))
        timer.sleep(step - (timer.time() - start) % step)
        now = timer.time() - start

================
File: limonata\utils.py
================
from serial.tools import list_ports  # type: ignore

sep: str = " "  # command/value separator in Reactor firmware

arduinos: list[tuple[str, str]] = [
    ("USB VID:PID=16D0:0613", "Arduino Uno"),
    ("USB VID:PID=1A86:7523", "NHduino"),
    ("USB VID:PID=2341:8036", "Arduino Leonardo"),
    ("USB VID:PID=2A03", "Arduino.org device"),
    ("USB VID:PID", "unknown device"),
]


def clip(val: float, lower: float = 0, upper: float = 100) -> float:
    """Limit value to be between lower and upper limits"""
    return max(lower, min(val, upper))


def command(name: str, argument: float, lower: float = 0, upper: float = 100) -> str:
    """Construct command to the firmware."""
    return name + sep + str(clip(argument, lower, upper))


def find_arduino(port: str = "") -> tuple[str | None, str | None]:
    """Locates Arduino and returns port and device."""
    comports: list[tuple[str, str, str]] = [
        tuple for tuple in list_ports.comports() if port in tuple[0]
    ]
    for port, desc, hwid in comports:
        for identifier, arduino in arduinos:
            if hwid.startswith(identifier):
                return port, arduino
    print("--- Serial Ports ---")
    for port, desc, hwid in list_ports.comports():
        print(port, desc, hwid)
    return None, None

================
File: limonata\version.py
================
__version__ = "0.1.0"

================
File: limonata\__init__.py
================
from .reactor import Reactor, ReactorModel  # , diagnose

# from .historian import Historian, Plotter
# from .experiment import Experiment, runexperiment
from .timer import timer  # , setnow, clock
# from .version import __version__


def setup(connected=True, speedup=1):
    """Set up a reactor session with simple switching between real and model reactor

    The idea of this function is that you will do

    >>> reactor = setup(connected=True)

    to obtain a reactor class reference. If `connected=False` then you will
    receive a ReactorModel class reference. This allows you to switch between
    the model and the real reactor in your code easily.

    The speedup option can only be used when `connected=False` and is the
    ratio by which the reactor clock will be sped up relative to real time
    during the simulation.

    For example

    >>> reactor = setup(connected=False, speedup=2)

    will run the reactor clock at twice real time (which means that the whole
    simulation will take half the time it would if connected to a real device).
    """

    if connected:
        reactor = Reactor
        if speedup != 1:
            raise ValueError("The real reactor must run in real time")
    else:
        reactor = ReactorModel
        if speedup < 0:
            raise ValueError(
                "speedup must be positive. " "You passed speedup={}".format(speedup)
            )

    timer.set_rate(speedup)
    return reactor

================
File: limonata\actuators\agitators.py
================
from limonata.actuators.base import Actuator
import serial

class Agitator(Actuator):
    def __init__(self, sp: serial.Serial, debug: bool = False) -> None:
        super().__init__(sp, debug)

    def __enter__(self) -> "Agitator":
        return self

================
File: limonata\actuators\base.py
================
from limonata.utils import clip, sep
from typing import Any
import serial

class Actuator:
    def __init__(self, sp: serial.Serial, debug: bool = False) -> None:
        self._Q = 0
        self.sp = sp
        self.debug = debug

    def __enter__(self) -> "Actuator":
        return self

    def send(self, msg: str) -> None:
        """Sends a string message to the firmware."""
        self.sp.write((msg + "\r\n").encode())
        if self.debug:
            print('Sent: "' + msg + '"')
        self.sp.flush()

    def receive(self) -> str:
        """Returns a string message received from the firmware."""
        msg = self.sp.readline().decode("UTF-8").replace("\r\n", "")
        if self.debug:
            print('Return: "' + msg + '"')
        return msg
    
    def send_and_receive(self, msg: str, convert: type = str) -> Any:
        """Send a string message and return the response."""
        self.send(msg=msg)
        return convert(self.receive())

    @property
    def Q(self) -> float:
        return self._Q
    
    def Q(self, val: float | None = None) -> float:
        """Get or set Actuator output
        val: Value of desired actuator input from 0-100 
        """
        if val is None:
            msg = "R"
        else:
            msg = "Q" + sep + str(clip(val=val))
        return self.send_and_receive(msg=msg, convert=str)

================
File: limonata\actuators\heaters.py
================
from limonata.actuators.base import Actuator
import serial


class Heater(Actuator):
    def __init__(self, sp: serial.Serial, debug: bool = False) -> None:
        super().__init__(sp, debug)
        self.link = "https://a.co/d/asBIGne"
        self.voltage_rating = 12 # V
        self.power_rating = 100 # W
        self.current_rating = self.power_rating/self.voltage_rating # A

    def __enter__(self) -> "Heater":
        return self

================
File: limonata\actuators\pumps.py
================
from limonata.actuators.base import Actuator
import serial


class Pump(Actuator):
    def __init__(self, sp: serial.Serial, debug: bool = False) -> None:
        super().__init__(sp, debug)

    def __enter__(self) -> "Pump":
        return self
    

class BrushlessPump(Pump):
    def __init__(self, sp: serial.Serial, debug = False):
        super().__init__(sp, debug)

    def __enter__(self) -> "BrushlessPump":
        return self

================
File: limonata\actuators\valves.py
================
from limonata.actuators.base import Actuator
import serial


class ControlValve(Actuator):
    def __init__(self, sp: serial.Serial | None = None, debug: bool = False) -> None:
        super().__init__(sp, debug)

    def __enter__(self) -> "ControlValve":
        return self

================
File: limonata\sensors\base.py
================
#from limonata.utils import clip, sep
from typing import Any
import serial

class Sensor:
    def __init__(self, sp: serial.Serial, debug: bool = False) -> None:
        self._output = None
        self.sp = sp
        self.debug = debug

    def __enter__(self) -> "Sensor":
        return self

    def send(self, msg: str) -> None:
        """Sends a string message to the firmware."""
        self.sp.write((msg + "\r\n").encode())
        if self.debug:
            print('Sent: "' + msg + '"')
        self.sp.flush()

    def receive(self) -> str:
        """Returns a string message received from the firmware."""
        msg = self.sp.readline().decode("UTF-8").replace("\r\n", "")
        if self.debug:
            print('Return: "' + msg + '"')
        return msg
    
    def send_and_receive(self, msg: str, convert: type = str) -> Any:
        """Send a string message and return the response."""
        self.send(msg=msg)
        return convert(self.receive())

    @property
    def output(self) -> float:
        """Returns a float of the sensor output."""
        return self.send_and_receive(msg='output', convert=float)

================
File: tests\test_reactor.py
================
# from limonata.reactor import Reactor
# import pytest as pt
# from unittest import mock


# @pt.fixture
# def reactor() -> Reactor:
#     """Fixture for creating a Reactor instance for each test."""
#     # Mock the serial connection
#     with mock.patch('serial.Serial') as mock_serial:
#         mock_serial.return_value.isOpen.return_value = True  # Simulate open connection
#         mock_serial.return_value.readline.return_value = b'OK\n'  # Simulate reading a line
#         mock_serial.return_value.write.return_value = None  # Simulate writing to serial
#         return Reactor(port="", debug=True)


# def test_reactor_initialization(reactor: Reactor) -> None:
#     """Test if the reactor connects and initializes correctly."""
#     reactor.connect(baud_rate=115200)
#     assert reactor.sp.isOpen()  # Ensure the serial connection is open
#     assert reactor.baud_rate == 115200  # Ensure the baud rate is set correctly


# def test_start_reactor(reactor: Reactor) -> None:
#     """Test if the reactor initializes with the correct default values."""
#     assert reactor.port is not None  # Ensure the port is set
#     assert reactor.baud_rate in [115200, 9600]  # Ensure valid baud rate
#     assert reactor.version.startswith("VERSION")  # Ensure version is set correctly
#     assert reactor.sp.isOpen()  # Ensure the serial connection is open


# def test_Q_control(reactor: Reactor) -> None:
#     """Test if the Q control works properly."""
#     reactor.connect(baud_rate=115200)
#     reactor.Q(100)  # Set the temperature to 100
#     assert reactor.Q() == 100  # Ensure the temperature is set to 100
